
<!DOCTYPE html>
	<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Transcendence</title>
    <meta name="description" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
	{% comment %} <link rel="stylesheet" type="text/css" href="{% static 'css/styles.css' %}"> {% endcomment %}
  </head>
  <style>
	.friend-list li {
		display: flex;
		align-items: center;
		padding: 10px;
		border-bottom: 1px solid #ccc;
	  }
	
	  .friend-list img {
		width: 40px;
		height: 40px;
		border-radius: 50%;
	  }
	
	  .friend-details {
		display: flex;
		flex-direction: column;
		align-items: center;
		margin-right: 10px;
	  }
	
	  .friend-info {
		display: flex;
		flex-direction: column;
		justify-content: center;
		flex-grow: 1;
	  }
	
	  .friend-info .name-and-buttons {
		display: flex;
		align-items: center;
	  }
	
	  .status-text {
		font-size: 12px;
		color: grey;
		margin-top: 5px;
	  }
	
	  .status-text.online {
		color: green;
	  }
	
	  .status-text.offline {
		color: grey;
	  }
	
	  .friend-list button {
		margin-left: 10px;
	  }
	
	  .chat-btn {
		position: absolute;
		right: 14px;
		bottom: 30px;
		cursor: pointer;
	  }
	
	  .chat-btn .close {
		display: none;
	  }
	
	  .chat-btn i {
		transition: all 0.9s ease;
	  }
	
	  #check:checked~.chat-btn i {
		display: block;
		pointer-events: auto;
		transform: rotate(180deg);
	  }
	
	  #check:checked~.chat-btn .comment {
		display: none;
	  }
	
	  .chat-btn i {
		font-size: 22px;
		color: #fff !important;
	  }
	
	  .chat-btn {
		width: 50px;
		height: 50px;
		display: flex;
		justify-content: center;
		align-items: center;
		border-radius: 50px;
		background-color: black;
		color: #fff;
		font-size: 22px;
		border: none;
	  }
	
	  .wrapper {
		position: absolute;
		right: 20px;
		bottom: 100px;
		width: 400px;
		background-color: #f0f0f0;
		border-radius: 5px;
		opacity: 0;
		transition: all 0.4s;
	  }
	
	  #check:checked~.wrapper {
		opacity: 1;
	  }
	
	  .header {
		padding: 13px;
		background-color: black;
		border-radius: 5px 5px 0px 0px;
		margin-bottom: 10px;
		color: #fff;
	  }
	
	  .chat-form {
		padding: 15px;
	  }
	
	  .chat-form input,
	  .chat-form textarea,
	  .btn-chat {
		margin-bottom: 10px;
	  }
	
	  .chat-form textarea {
		resize: none;
		overflow-y: auto;
	  }
	
	  .form-control:focus,
	  .btn-chat:focus {
		box-shadow: none;
	  }
	
	  .btn-chat,
	  .btn-chat:focus,
	  .btn-chat:hover {
		background-color: black;
		border: blue;
		border-radius: 5px;
		color: #fff;
	  }
	
	  #check {
		display: none !important;
	  }
	
	  #leave {
		width: calc(30% - 5px);
		display: inline-block;
		margin-top: 7px;
	  }
	
	  #send {
		width: calc(70% - 5px);
		display: inline-block;
		margin-top: 7px;
	  }
	{% comment %} body {
	  background-color: #333;
	  color: white;
	} {% endcomment %}
	
	</style>
  <body>

	{% include "navbar.html" %}
	
    <main id="oldContent">
		{% block content %}{% endblock content %}
    </main>
	
	<div id="chatRoom">

		{% include "chatroom.html" %}

	</div>

	<script>	
	
		function updateContent(path) {
			fetch(path)
			.then(response => {
				if (!response.ok) {
				  if (response.status === 401) {
					updateContent("/login/");
				  } else if (response.status === 403) {
					updateContent("/login/");
				  } else {
					throw new Error("Unexpected Error");
				  }
				}
				return response.text();
			})
			.then(html => {
			const parser = new DOMParser();
			const doc = parser.parseFromString(html, "text/html");
			const newContent = doc.querySelector("#newContent"); 
			const oldContent = document.getElementById("oldContent");
			oldContent.innerHTML = ""; 
			oldContent.appendChild(newContent);
			reattachEventListeners();
			 })
			 .catch(error => console.error('Error fetching content:', error));
		  };

		function handleRoute(event, path) {
			event.preventDefault();
			if (window.location.pathname !== path) {
				window.history.pushState({path: path}, '', path);
				updateContent(path);
			}
		}

		function reattachEventListeners(){
			loginButton()
			login()
			logout()
			generateQRCode()
			validateOTP()
			oauth()
			homeButton()
			defaultButton()
			bindProfileButton()
			soloGame()
			multiplayerGame()
			handleCheckbox()
			checkBox()
			setNewPasswd()
		}

		function setNewPasswd(){
			const passwd = document.getElementById("newPasswdButton");
			if (passwd) {
				passwd.addEventListener("click", async function(event){
					event.preventDefault();
					const oldPassword = document.getElementById('oldPassword').value;
					const password = document.getElementById('password').value;
					const confirmPassword = document.getElementById('confirmPassword').value;

					if(password !== confirmPassword){
						alert("Passwords do not match! Try again!")
					}
					else{
						const csrftoken = getCookie("csrftoken")
						try{
							const response = await fetch("/api/set_new_passwd/", {
								method: "POST",
								headers: {
									"Content-Type": "application/json",
									"X-CSRFToken": csrftoken,
									'Cache-Control': 'no-cache'
								},
								body: JSON.stringify({password:confirmPassword, old_passwd:oldPassword})
							});
							if(!response.ok){
								alert(response.error);
							}
							alert("Setting your new password was successful!")
						}
						catch(error) {
							console.error("something went wrong");
						}
					}
				});
			}
		}



		async function activatetwoFA(){
			try {
				const csrftoken = getCookie("csrftoken");
				const response = await fetch("/api/Update_2FA_Status/", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						'Cache-Control': 'no-cache',
						"X-CSRFToken": csrftoken,
					},
					body: JSON.stringify({ enable: true })
				});
				if (!response.ok) {
					throw new Error("Changing twoFA failed");
				}
				else{
					alert("2FA activated")
				}
			} catch (error) {
				console.error("Token refresh error:", error);
			}
		}

		async function deactivatetwoFA(){
			try {
				const csrftoken = getCookie("csrftoken");
				const response = await fetch("/api/Update_2FA_Status/", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						'Cache-Control': 'no-cache',
						"X-CSRFToken": csrftoken,
					},
					body: JSON.stringify({ enable: false })
				});
				if (!response.ok) {
					throw new Error("Changing twoFA failed");
				}
				else{
					alert("2FA deactivated!")
				}
			} catch (error) {
				console.error("Token refresh error:", error);
			}
		}

		
		async function checkBox() {
			const checkBox = document.getElementById('checkBox');
			if (checkBox) {
			  try {
				const csrftoken = getCookie("csrftoken");
				const twoFAResponse = await fetch("/api/get_2fa_status/", {
				  method: "GET",
				  headers: {
					"Content-Type": "application/json",
					"X-CSRFToken": csrftoken,
					'Cache-Control': 'no-cache'
				  },
				});
				if (!twoFAResponse.ok) throw new Error("Getting 2FA status failed");
				
				const twoFAResponseData = await twoFAResponse.json();
				if (twoFAResponseData.enable === true) {
				  checkBox.checked = true;
				}
				else{
					checkBox.checked = false;
				}
			  } catch (error) {
				console.error(error);
			  }
			}
		  };

		  window.onload = async function() {
			checkBox();
		  };


		function handleCheckbox(){
			const checkBox = document.getElementById("checkBox");
			if(checkBox){
				checkBox.addEventListener("change", function(){
					if(checkBox.checked)
						activatetwoFA();
					else{
						deactivatetwoFA();
					}
				});
			}
		}
		
		async function getUsernameFromBackend(token) {
			try {
				const response = await fetch("/api/get_username", {
					method: "GET",
					headers: {
						"Authorization": `Bearer ${token}`,
					}
				});
				if (response.ok) {
					const userData = await response.json();
					const username = userData.username;
					return username;
				} else {
					throw new Error("Failed to get username from backend");
				}
			} catch (error) {
				console.error("Error getting username from backend:", error);
				throw error;
			}
		}
		

		async function checkAccessToken() {
			const token = localStorage.getItem("access_token");
			if (token) {
				try {
					const response = await fetch("/token/verify/", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
							"Authorization": `Bearer ${token}`,
						},
						body: JSON.stringify({ token: token }),
					});
					if (response.ok) {
						const username = await getUsernameFromBackend(token);
						showLoggedInState(username);
					} else {
						showLoggedOutState();
						console.log("hello");
					}
				} catch (error) {
					console.error("Error verifying token:", error);
					showLoggedOutState();
				}
			} else {
				showLoggedOutState();
			}
		};


		document.addEventListener("DOMContentLoaded", checkAccessToken);



			const showLoggedInState = (username) => {
				navButtons.innerHTML = `
				<button class="nav-button" id="homeButton">Transcendence</button>
				<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
				  <span class="navbar-toggler-icon"></span>
				</button>
				<li class="nav-item">
					<button class="nav-button" id="game" >Solo Game</button>
				</li>

					<li class="nav-item dropdown">
						<button class="nav-button dropdown-toggle" id="friendsDropdown" data-bs-toggle="dropdown" aria-expanded="false">
							Friends
						</button>
						<ul class="dropdown-menu" aria-labelledby="friendsDropdown">
							<li>
								<input type="text" id="search-friends" class="form-control" placeholder="Search user...">
							</li>
							<li id="search-results"></li>
							<div id="friend-requests"></div>
							<div class="dropdown-divider"></div>
							<h5 class="dropdown-header">Friends</h5>
							<div id="friends-list"></div>
						</ul>
					</li>
					<li class="nav-item">
						<button class="nav-button" id="multiplayerGame" >Play Multiplayer</button>
					</li>
					<li class="nav-item dropdown">
						<button class="nav-button dropdown-toggle" id="navbarDropdownMenuLink" data-bs-toggle="dropdown" aria-expanded="false">
							${username}
						</button>
						<ul class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
							<li><button class="dropdown-item" id="profile" >View Profile</button></li>
							<li><hr class="dropdown-divider"></li>
							<li><button class="dropdown-item" id="logout">Logout</button></li>
						</ul>
					</li>
				`;
				reattachEventListeners();
			};
		
			// Function to display UI for logged-out state
			const showLoggedOutState = () => {
				navButtons.innerHTML = `
				<button class="nav-button" id="defaultButton">Transcendence</button>
				<li class="nav-item">
					<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
						<span class="navbar-toggler-icon"></span>
					</button>
				</li>
				<li class="nav-item">
					<button class="nav-button login-button" id="login">Login</button>
				</li>
				<li class="nav-item">
					<button class="nav-button" id="register" >Authenticate with 42</button>
				</li>
			`;
				reattachEventListeners();
			};

			
		function soloGame(){
			const soloGameButton = document.getElementById("game");
			if (soloGameButton) {
				soloGameButton.addEventListener("click", function(event) {
					event.preventDefault();
					handleRoute(event, "/game/");
				});
			}
		}

		function multiplayerGame(){
			const multiplayerGame = document.getElementById("multiplayerGame");
			if (multiplayerGame) {
				multiplayerGame.addEventListener("click", function(event) {
					event.preventDefault();
					handleRoute(event, "/multiplayer/");
				});
			}
		}

		function loginButton(){
			const loginButton = document.getElementById("login");
			if(loginButton){
				loginButton.addEventListener("click", function(event) {
					event.preventDefault();
					handleRoute(event, "/login/");
			});	
		}
	}


		function defaultButton(){
			const defaultButton = document.getElementById("defaultButton");
			if(defaultButton){
				defaultButton.addEventListener("click", function(event) {
					event.preventDefault();
					window.history.pushState({ path: '/' }, '', '/');
					const oldContent = document.getElementById("oldContent");
					if(oldContent){
						oldContent.innerHTML = "";
					}
			});
		}
	}

		function homeButton(){
			const homeButton = document.getElementById("homeButton");
			if(homeButton){
				homeButton.addEventListener("click", function(event) {
					event.preventDefault();
					window.history.pushState({ path: '/home/' }, '', '/home/');
					updateContent("/home/");
			});
		}
	}

	 window.onload = function () {
		const currentUrl = window.location.href;
		console.log(currentUrl);
		if (currentUrl.includes('profile')) {
			fetchProfileData();
		}
		bindSaveChangesButton();
		bindProfileButton();
	};
	
	document.addEventListener('DOMContentLoaded', function() {
		const currentUrl = window.location.href;
		console.log(currentUrl);
		if (currentUrl.includes('profile')) {
			fetchProfileData();
		}
		bindSaveChangesButton();
		bindProfileButton();
	});
	
	function fetchProfileData() {
		fetch('/api/get_profile/', {
			method: 'GET',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			console.log('Raw Response Status:', response.status);
			return response.text();
		})
		.then(rawData => {
			try {
				const data = JSON.parse(rawData);
				console.log('Raw Response Data:', data); // Log raw data
				if (data) {
					document.getElementById('profile-name').textContent = data.username;
					document.getElementById('profile-username').value = data.username;
					document.getElementById('profile-email').value = data.email;
					document.getElementById('profile-display_name').value = data.display_name;
					document.getElementById('profile-picture_url').value = data.picture_url;
					const profilePictureUrl = data.profile_picture;
					if (profilePictureUrl) {
						console.log(profilePictureUrl);
						const profilePicture = document.getElementById('profile-picture');
						profilePicture.setAttribute('src', profilePictureUrl);
					}
				}
			} catch (error) {
				console.error('Error parsing JSON:', error);
			}
		})
		.catch(error => {
			console.error('Error fetching profile data:', error);
		});
	}
	
	async function saveChanges() {
		const picture_url = document.getElementById("profile-picture_url").value;
		const display_name = document.getElementById("profile-display_name").value;
		const csrftoken = getCookie("csrftoken")
		try {
			const response = await fetch("/api/save_changes/", {
				method: "PUT",
				headers: {
					"Content-Type": "application/json",
					"X-CSRFToken": csrftoken,
				},
				body: JSON.stringify({ display_name: display_name, picture_url: picture_url })
			});
			if (!response.ok) {
				const errorData = await response.json();
				alert(errorData.error);
			} else {
				alert("Settings got changed");
				fetchProfileData();
			}
		} catch (error) {
			console.error("Something went wrong:", error);
		}
	}
	
	function bindSaveChangesButton() {
		const saveChangesButton = document.getElementById("saveChangesButton");
		if (saveChangesButton) {
			saveChangesButton.addEventListener("click", function(event) {
				event.preventDefault();
				saveChanges();
			});
		}
	}
	
	function bindProfileButton() {
		const profileButton = document.getElementById("profile");
		if (profileButton) {
			profileButton.addEventListener("click", function(event) {
				event.preventDefault();
				handleRoute(event, "/profile/");
				fetchProfileData();
			});
		}
	}

		function set_passwd(){
			const passwd = document.getElementById("passwordForm");
			if (passwd) {
				passwd.addEventListener("click", async function(event){
					event.preventDefault();
					const password = document.getElementById('password').value;
					const confirmPassword = document.getElementById('confirmPassword').value;

					if(password !== confirmPassword){
						alert("Passwords do not match! Try again!")
					}
					else{
						const csrftoken = getCookie("csrftoken")
						try{
							const response = await fetch("/api/set_passwd/", {
								method: "POST",
								headers: {
									"Content-Type": "application/json",
									"X-CSRFToken": csrftoken,
									'Cache-Control': 'no-cache'
								},
								body: JSON.stringify({password:confirmPassword})
							});
							if(!response.ok){
								alert(response.error);
							}
							alert("Setting your passwd was successful!")
							window.history.pushState({ path: '/login/' }, '', '/login/');
							updateContent("/login/");
						}
						catch(error) {
							console.error("something went wrong");
						}
					}
				});
			}
		}

			window.onload = function(){
				const registration = document.getElementById("passwordForm");
				if (registration) {
					const currentUrl = window.location.href;
					if (currentUrl.includes('/set_')) {
							fetch("/api/fetch_user_data/")
								.then(response => response.json())
								.then(data => {
									if (data.error) {
										alert("Already logged in");
										window.history.pushState({ path: '/login/' }, '', '/login/');
										updateContent("/login/");
									}
									console.log("Getting User data successful");
								})
								.catch(error => {
									console.error('Error during fetch:', error);
								});
						}
					}
			}

		function oauth() {
			const registerButton = document.getElementById("register");
			if (registerButton) {
				registerButton.addEventListener("click", () => {
					fetch("/api/oauth/")
						.then(response => {
							if (!response.ok) {
								return response.text().then(text => {
									throw new Error(`Network response was not ok: ${response.statusText}\n${text}`);
								});
							}
							return response.json();
						})
						.then(data => {
							window.location.href = data.url;
						})
						.catch(error => {
							console.error('Error during fetch:', error);
						});
				});
			}
		}

		function logout() {
			const logoutButton = document.getElementById("logout");
			if (logoutButton) {
				logoutButton.addEventListener("click", async function(event) {
					event.preventDefault();
					const refreshToken = localStorage.getItem("refresh_token");
					const csrftoken = getCookie("csrftoken");
					try {
						const response = await fetch("/api/logout/", {
							method: "POST",
							headers: {
								"Content-Type": "application/json",
								"X-CSRFToken": csrftoken,
								'Cache-Control': 'no-cache'
							},
							body: JSON.stringify({ refresh_token: refreshToken })
						});
						if (!response.ok)
							throw new Error("Logout fail");
						localStorage.removeItem('access_token');
						localStorage.removeItem('refresh_token');
						setLoginStatus('false');
						checkAccessToken();
						window.history.pushState({ path: '/login/' }, '', '/login/');
						updateContent("/login/");
				
					} catch (error) {
						console.log("Error in logout", error);
					}
				});
			}
		}

		function login() {
			const Login = document.getElementById("loginFormContent");
			if (Login) {
				Login.addEventListener("submit", async function(event) {
					event.preventDefault();
					console.log("test");
					const username = document.getElementById("username").value;
					const password = document.getElementById("password").value;
					const csrftoken = getCookie("csrftoken");
	
					try {
						const response = await fetch("/api/login/", {
							method: "POST",
							headers: {
								"Content-Type": "application/json",
								"X-CSRFToken": csrftoken,
								'Cache-Control': 'no-cache'
							},
							body: JSON.stringify({ username, password }),
						});
						if (!response.ok) 
							throw new Error("Login failed");
						
						const twoFAResponse = await fetch("/api/get_2fa_status/", {
							method: "GET",
							headers: {
								"Content-Type": "application/json",
								"X-CSRFToken": csrftoken,
								'Cache-Control': 'no-cache'
							},
						});
						if (!twoFAResponse.ok)
							throw new Error("Getting 2FA status failed");
						const twoFAResponseData = await twoFAResponse.json();
						if (twoFAResponseData.enable === true) {
							console.log("that");
							window.history.pushState({ path: '/2FA/' }, '', '/2FA/');
							updateContent("/2FA/");
							await getAccessToken(username, password, csrftoken);
						}
						else{
							console.log("this");
							await getAccessToken(username, password, csrftoken);
							setLoginStatus('true');
							window.history.pushState({ path: '/home/' }, '', '/home/');
							updateContent("/home/");
							checkAccessToken();
						}
					} catch(error) {
						console.error("Login error:", error);
						alert("Login failed. Please try again.");
					}
				});
			}
		}



		
        function validateOTP() {
            const validateButton = document.getElementById("validateOTP");
            if (validateButton) {
                validateButton.addEventListener("click", function(event) {
                    event.preventDefault();
                    const otp = document.getElementById("otpInput").value;
					const csrftoken = getCookie("csrftoken");
                    fetch("/api/validateOTP/", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
							"X-CSRFToken": csrftoken,
							'Cache-Control': 'no-cache'
                        },
                        body: JSON.stringify({otp: otp })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.valid) {
							window.history.pushState({ path: '/home/' }, '', '/home/');
							checkAccessToken();
							updateContent("/home/");
                        } else {
                            alert("Validation failed: Invalid OTP");
                        }
                    })
                    .catch(error => {
                        console.error("Error:", error);
                        alert("An error occurred while validating the OTP");
                    });
                });
            }
        }


		function generateQRCode() {
			const qrcodeButton = document.getElementById("generateQRCode");
			if (qrcodeButton) {
				qrcodeButton.addEventListener("click", function(event) {
					event.preventDefault();
					fetch("/api/setup-2fa", {
						method: "GET",
						headers: {
							"Content-Type": "application/json",
							'Cache-Control': 'no-cache'
						}
					})
					.then(response => {
						if (!response.ok) {
							throw new Error("Network response was not ok");
						}
						return response.text();
					})
					.then(responseText => {
						const data = JSON.parse(responseText);
						const qrCodeImg = document.getElementById("qrcode");
						qrCodeImg.src = "data:image/png;base64," + data.qr_code;
					})
					.catch(error => {
						console.log("Error:", error);
					});
				});
			}
		}
		


		window.addEventListener('popstate', function(event) {
			if (event.state && event.state.path) {
				updateContent(event.state.path);
			}
		});


		
//need to call the logout endpoint

	document.addEventListener("DOMContentLoaded", function() {
		reattachEventListeners();
	});


	function checkJWTToken(){
		const access_token = localStorage.getItem('access_token')
		if (access_token === null && isLoggedIn()){
			setLoginStatus('false')
			window.history.pushState({ path: '/home/' }, '', '/home/');
			updateContent("/home/");
		}

	}

	function setLoginStatus(status){
		localStorage.setItem('loginStatus', status);
	}

	function isLoggedIn(){
		const loggedIn = localStorage.getItem('loginStatus');
		return loggedIn === 'true';
	}

	setInterval(checkJWTToken, 5000);
		

	function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== "") {
            const cookies = document.cookie.split(";");
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === name + "=") {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    async function getAccessToken(username, password, csrftoken) {
        try {
            const response = await fetch("/token/", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": csrftoken,
					'Cache-Control': 'no-cache'
                },
                body: JSON.stringify({ username, password }),
            });

            if (!response.ok) {
                throw new Error("Token failed");
            }
            const data = await response.json();
            localStorage.setItem("access_token", data.access);
            localStorage.setItem("refresh_token", data.refresh);
        } catch (error) {
            console.error("Token error:", error);
            alert("Token");
        }
    }
//test if refresh token is null
    async function refreshToken() {
        const refreshToken = localStorage.getItem("refresh_token");
        try {
            const response = await fetch("/token/refresh/", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
					'Cache-Control': 'no-cache'
                },
                body: JSON.stringify({ refresh: refreshToken }),
            });

            if (!response.ok) {
                throw new Error("Token refresh failed");
            }
            const data = await response.json();
            localStorage.setItem("access_token", data.access);
        } catch (error) {
            console.error("Token refresh error:", error);
            alert("Token refresh failed. Please login again.");
			window.history.pushState({ path: '/home/' }, '', '/home/');
			updateContent("/home/");
		}
    }

	function setLoginStatus(status){
		localStorage.setItem('loginStatus', status);
	}
	//check if token is null, protect routes in backend if there is no token anymore
	function isLoggedIn(){
		const loggedIn = localStorage.getItem('loginStatus');
		return 
	}

	function reset(){
		document.getElementById("myForm").style.display = "block";
		document.getElementById("board").style.display = "none";
		document.getElementById("resetGameButton").style.display = "none";
	  }
	
	  window.onload = function() {
		const currentUrl = window.location.href;
		if (currentUrl.includes('game')){
			document.getElementById("background").value = "#ffffff"; // Default to white
			document.getElementById("borders").value = "#0000ff"; // Default to blue
			document.getElementById("ballColor").value = "#0000ff"; // Default to blue
		}
	  }
	
	  function start_game() {
		//board vars
		let board;
		let context;
		let boardWidth = 900;
		let boardHeight = 500;
	
		// player vars
		let playerWidth = 10;
		let playerHeight = 100;
		let playerSpeedY = 0;
	
		//ball vars
		let ballWidth = 10;
		let ballHeight = 10;
		let ballSpeed = document.getElementById("ballSpeed").value;
		let random = Math.random() > 0.5 ? 1 : -1;
		let ballAngle = random * Math.PI / 4;
		random = Math.random() > 0.5 ? 1 : -1;
	
		//score vars
		let score1 = 0;
		let score2 = 0;
		let maxScore = document.getElementById("maxScore").value;
	
	
		let advanced_mode = document.getElementById("advancedMode").checked;
		let power_up_mode = document.getElementById("powerUps").checked;
		let size_power_up_used = false;
		let speed_power_up_used = false;
	
		//coordinates of the power Ups
		let size_x = boardWidth/2;
		let size_y = boardHeight/4;
	
		let speed_x = boardWidth/2;
		let speed_y = boardHeight/4 * 3;
	
		//game classes
		let player1 = {
		  x: 10,
		  y: boardHeight / 2 - playerHeight/2,
		  width: playerWidth,
		  height: playerHeight,
		  curr_speedY: 0,
		  movespeed: 0
		}
	
		let player2 = {
		  x: boardWidth - playerWidth - 10,
		  y: boardHeight / 2 - playerHeight/2,
		  width: playerWidth,
		  height: playerHeight,
		  curr_speedY: 0,
		  movespeed: 0
		}
	
		let ball = {
		  x: boardWidth/2,
		  y: boardHeight/2,
		  width: ballWidth,
		  height: ballHeight,
		  speedX: random * ballSpeed * Math.cos(ballAngle),
		  speedY: ballSpeed * Math.sin(ballAngle)
		}
	
		if (check_input_froms() == -1)
		  return ;
		player1.curr_speedY = playerSpeedY;
		player2.curr_speedY = playerSpeedY;
		document.getElementById("myForm").style.display = "none";
		board = document.getElementById("board");
		board.height = boardHeight;
		board.width = boardWidth;
		context = board.getContext("2d");
	
		//color customization
		board.style.display = "block";
		board.style.backgroundColor = document.getElementById("background").value;
		board.style.borderTop = "5px solid " + document.getElementById("borders").value;
		board.style.borderBottom = "5px solid " + document.getElementById("borders").value;
		board.style.borderLeft = "5px solid " + document.getElementById("borders").value;
		board.style.borderRight = "5px solid " + document.getElementById("borders").value;
	
	
		//fill the board with our classes
		context.fillStyle = document.getElementById("ballColor").value;
		context.fillRect(player1.x, player1.y, player1.width, player1.height);
		context.fillRect(player2.x, player2.y, player2.width, player2.height);
	
		//key listener if key is pressed
		window.addEventListener('keydown', (event) => {
			if (event.code == 'KeyW') {
			  if (player1.y > 0)
				player1.movespeed = -(player1.curr_speedY);
			  else{
				player1.movespeed = 0;
				player1.y = 0;
			  }
			}
			else if (event.code == 'KeyS') {
			  if (player1.y + player1.height < boardHeight)
				player1.movespeed = player1.curr_speedY;
			  else{
				player1.movespeed = 0;
				player1.y = boardHeight - player1.height;
			  }
		   }
	
			if (event.code == 'ArrowUp') {
			  if (player2.y > 0)
				player2.movespeed = -(player2.curr_speedY);
			  else{
				player2.movespeed = 0;
				player2.y = 0;
			  }
			}
			else if (event.code == 'ArrowDown') {
			  if (player2.y + player2.height < boardHeight)
				player2.movespeed = player2.curr_speedY;
			  else{
				player2.movespeed = 0;
				player2.y = boardHeight - player2.height;
			  }
			}
		})
		//event listener for key gets released
		window.addEventListener('keyup', (e) => {
		  if (e.code == 'KeyW') {
			player1.movespeed = 0;
		  }
		  else if (e.code == 'KeyS') {
			player1.movespeed = 0;
		  }
	
		  if (e.code == 'ArrowUp') {
			player2.movespeed = 0;
		  }
		  else if (e.code == 'ArrowDown') {
			player2.movespeed = 0;
		  }
		});
		 // Start the game loop and end if game is won
		update();
	
	  function update() {
		let id = requestAnimationFrame(update);
		context.clearRect(0, 0, board.width, board.height); // Clear the canvas
	
		context.fillStyle = document.getElementById("borders").value;
	
		context.fillStyle = document.getElementById("ballColor").value;
		check_and_change_dir_ball();
	
		ball.x += ball.speedX;
		ball.y += ball.speedY;
		drawCircle(context, ball.x, ball.y, ball.width/2);
	
		if (power_up_mode == true){
		  //check if the size power up is collected and change accordingly
		  check_size_power_up();
	
		  //check if the speed power up is collected and change accordingly
		  check_speed_power_up();
		}
	
		// check if player paddle is out of the frame otherwise change player paddle x and y
		check_and_change_dir_player();
	
		if (check_and_change_score() == 1){
		  cancelAnimationFrame(id);
		  document.getElementById("resetGameButton").style.display = "block";
		}
		context.font = "45px Verdana";
		context.fillText(score1, boardWidth/5, 45);
		context.fillText(score2, boardWidth/5 * 4, 45);
	  }
	
	  function check_size_power_up(){
		if (size_power_up_used == false){
		  if (size_y < 0)
			size_y = boardHeight;
		  else
			size_y -= 3;
		  drawArrow(context, size_x, size_y, 40);
		}
		if (size_power_up_used == false && areBallsTouching(ball.x, ball.y, ball.width/2, size_x, size_y, 20)){
		  if (ball.speedX > 0)
			player1.height *= 2;
		  else
			player2.height *= 2;
		  size_power_up_used = true;
		}
	  }
	
	  function check_speed_power_up(){
		if (speed_power_up_used == false){
		  if (speed_y + 20 > boardHeight)
			speed_y = 0;
		  else
			speed_y += 3;
		  drawStar(context, speed_x, speed_y, 20, 20);
		}
		if (speed_power_up_used == false && areBallsTouching(ball.x, ball.y, ball.width/2, speed_x, speed_y, 20)){
		  if (ball.speedX > 0)
			player1.curr_speedY *= 2.5;
		  else
			player2.curr_speedY *= 2.5;
		  speed_power_up_used = true;
		}
	  }
	
	  function drawCircle(ctx, x, y, radius) {
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2);
		ctx.closePath();
		ctx.fill();
	  }
	
	  function drawArrow(ctx, x, y, size) {
		var halfSize = size / 2;
		var tipY = y - size;
		var topX = x;
		var topY = y - halfSize;
		var bottomLeftX = x - halfSize;
		var bottomLeftY = y;
		var bottomRightX = x + halfSize;
		var bottomRightY = y;
		var bodyHeight = size / 4; // Height of the arrow's body
	
		ctx.fillRect(x - size / 6, y, size / 3, bodyHeight * 1.5);
	
		ctx.beginPath();
		ctx.moveTo(topX, topY);
		ctx.lineTo(bottomLeftX, bottomLeftY);
		ctx.lineTo(bottomRightX, bottomRightY);
		ctx.lineTo(topX, topY);
		ctx.lineTo(x, tipY);
		ctx.closePath();
	
		ctx.fill();
	  }
	
	  function drawStar(ctx, x, y, size) {
		ctx.beginPath();
		for (var i = 0; i < 5; i++) {
			ctx.lineTo(x + size * Math.cos((18 + i * 72) / 180 * Math.PI),
					   y - size * Math.sin((18 + i * 72) / 180 * Math.PI));
			ctx.lineTo(x + size / 2 * Math.cos((54 + i * 72) / 180 * Math.PI),
					   y - size / 2 * Math.sin((54 + i * 72) / 180 * Math.PI));
		}
		ctx.closePath();
		ctx.lineWidth = 3;
		ctx.fill();
	  }
	
	  function degreesToRadians(degrees) {
		return degrees * Math.PI / 180;
	  }
	
	  function mapValue(value, start1, stop1, start2, stop2) {
		return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
	  }
	
	  function areBallsTouching(ball1_x, ball1_y, ball1_radius, ball2_x, ball2_y, ball2_radius) {
		var distanceBetweenCenters = Math.sqrt(Math.pow(ball1_x - ball2_x, 2) + Math.pow(ball1_y - ball2_y, 2));
		var sumOfRadii = ball1_radius + ball2_radius;
		return distanceBetweenCenters <= sumOfRadii;
	  }
	
	  function check_and_change_dir_ball() {
		if (ball.y > boardHeight - ball.height/2){
		  if (advanced_mode == true)
				ball.y = 1;
		  else
			  ball.speedY *= -1;
		}
		if (ball.y < 0){
			if (advanced_mode == true)
				ball.y = boardHeight - ballHeight/2 - 1;
			else
				ball.speedY *= -1;
		}
		if (ball.x <= player1.x + player1.width && ball.x + ball.width >= player1.x
		  && ball.y + ball.height >= player1.y && ball.y <= player1.y + player1.height){
		  if (ball.x < player1.x + player1.width){
			let diff = ball.y - (player1.y + player1.height/2);
			let rad = degreesToRadians(45);
			let angle = mapValue(diff, -player1.height/2, player1.height/2, -rad, rad);
			ball.speedX = ballSpeed * Math.cos(angle);
			ball.speedY = ballSpeed * Math.sin(angle);
		  }
		}
		else if (ball.x + ball.width >= player2.x && ball.x <= player2.x + player2.width
			&& ball.y <= player2.y + player2.height && ball.y + ball.height >= player2.y){
			if (ball.x > player2.x){
			  let diff = ball.y - (player2.y + player2.height/2);
			  let angle = mapValue(diff, -player2.height/2, player2.height/2, degreesToRadians(225), degreesToRadians(135));
			  ball.speedX = ballSpeed * Math.cos(angle);
			  ball.speedY = ballSpeed * Math.sin(angle);
			}
		  }
	  }
	
	  function check_and_change_dir_player() {
		if (player1.y < 0)
		  player1.y = 1
		else if (player1.y > boardHeight - player1.height)
		  player1.y = boardHeight - player1.height;
		else
		  player1.y += player1.movespeed;
		context.fillRect(player1.x, player1.y, player1.width, player1.height);
	
		if (player2.y < 0)
		  player2.y = 1
		else if (player2.y > boardHeight - player2.height)
		  player2.y = boardHeight - player2.height;
		else
		  player2.y += player2.movespeed;
		context.fillRect(player2.x, player2.y, player2.width, player2.height);
	  }
	
	  function reset_game() {
		speed_power_up_used = false;
		size_power_up_used = false;
		player1.curr_speedY = playerSpeedY;
		player2.curr_speedY = playerSpeedY;
		player1.height = playerHeight;
		player2.height = playerHeight;
		ball.x = boardWidth/2;
		ball.y = boardHeight/2;
		size_x = boardWidth/2;
		size_y = boardHeight/4;
		speed_x = boardWidth/2;
		speed_y = boardHeight/4 * 3;
	
	
		let random = Math.random() * 2 - 1;
		let ballAngle = random * Math.PI / 4;
		ball.speedX = ballSpeed * Math.cos(angle);
		ball.speedY = ballSpeed * Math.sin(angle);
		context.fillRect(player1.x, player1.y, player1.width, player1.height);
		context.fillRect(player2.x, player2.y, player2.width, player2.height);
		drawCircle(context, ball.x, ball.y, ball.width/2);
	  }
	
	  function check_and_change_score() {
		if (ball.x < 0){
		  score2++;
		  ball.speedX *= -1;
		  reset_game();
		}
		else if (ball.x > boardWidth){
		  score1++;
		  ball.speedX *= -1;
		  reset_game();
		}
		if (score1 >= maxScore) {
		  context.clearRect(0, 0, board.width, board.height);
		  context.font = "90px sans-serif";
		  context.fillText("Winner: Player 1", boardWidth/2 - 320, 160);
		  return 1;
		}
		else if (score2 >= maxScore) {
		  context.clearRect(0, 0, board.width, board.height);
		  context.font = "90px sans-serif";
		  context.fillText("Winner: Player 2", boardWidth/2 - 320, 160);
		  return 1;
		}
		return 0;
	  }
		function check_input_froms() {
		  if (maxScore === "" || ballSpeed === "")
			return -1;
		  else{
			maxScore = parseInt(maxScore);
			if (maxScore > 12 || maxScore <= 3)
			  return -1;
			ballSpeed = parseInt(ballSpeed);
			if (ballSpeed > 20 || ballSpeed <= 3)
			  return -1;
			playerSpeedY = Math.floor(ballSpeed/2);
		  }
		  return 0;
		}
	  };
	
	  document.addEventListener("DOMContentLoaded", function() {
		let chatSocket;
		let selectedFriendId = null;
	
		function loadFriends() {
		  // Fetch the list of friends from the server (replace with your actual endpoint)
		  fetch('/api/friends/')
			.then(response => response.json())
			.then(data => {
			  const friendList = document.getElementById('friendList');
			  friendList.innerHTML = ''; // Clear the list
			  data.forEach(friend => {
				const li = document.createElement('li');
				li.id = `friend-${friend.user_id}`;
				li.dataset.friendId = friend.user_id;
	
				const img = document.createElement('img');
				img.src = friend.profile_picture_url;
				img.alt = friend.display_name;
	
				const statusText = document.createElement('span');
				statusText.id = `chat-status-${friend.user_id}`;
				statusText.className = 'status-text ' + (friend.is_online ? 'online' : 'offline');
				statusText.textContent = friend.is_online ? 'online' : 'offline';
	
				const friendDetails = document.createElement('div');
				friendDetails.className = 'friend-details';
				friendDetails.appendChild(img);
				friendDetails.appendChild(statusText);
	
				const friendInfo = document.createElement('div');
				friendInfo.className = 'friend-info';
	
				const nameAndButtons = document.createElement('div');
				nameAndButtons.className = 'name-and-buttons';
	
				const span_name = document.createElement('span');
				span_name.textContent = friend.display_name;
	
				const messageButton = document.createElement('button');
				messageButton.textContent = 'Message';
				messageButton.onclick = () => selectFriend(friend.user_id, friend.display_name);
	
				const blockButton = document.createElement('button');
				blockButton.textContent = 'Block';
				blockButton.onclick = () => blockUser(friend.user_id);
	
				const unblockButton = document.createElement('button');
				unblockButton.textContent = 'Unblock';
				unblockButton.onclick = () => unblockUser(friend.user_id);
				unblockButton.style.display = 'none'; // Hide the unblock button initially
	
				if (friend.is_blocked) {
				  messageButton.style.display = 'none';
				  blockButton.style.display = 'none';
				  statusText.style.display = 'none';
				  unblockButton.style.display = 'inline';
				}
	
				if (friend.blocked_by)
				  statusText.style.display = 'none';
	
				nameAndButtons.appendChild(span_name);
				nameAndButtons.appendChild(messageButton);
				nameAndButtons.appendChild(blockButton);
				nameAndButtons.appendChild(unblockButton);
	
				friendInfo.appendChild(nameAndButtons);
	
				li.appendChild(friendDetails);
				li.appendChild(friendInfo);
				friendList.appendChild(li);
			  });
			});
		}
	
		function selectFriend(friendId, friendName) {
		  selectedFriendId = friendId;
		  document.getElementById('friend-name').textContent = friendName;
		  document.getElementById('chatRoom').style.display = 'block';
		  document.getElementById('friendsList').style.display = 'none';
		  document.getElementById('message').disabled = false;
		  document.getElementById('send').disabled = false;
		  loadMessages(friendId);
		  initializeWebSocket(friendId);
		}
	
		function loadMessages(friendId) {
		  // Fetch the chat messages from the server (replace with your actual endpoint)
		  fetch(`/api/messages/${friendId}/`)
			  .then(response => response.json())
			  .then(data => {
				  // Check if the response contains messages
				  if (data.messages && Array.isArray(data.messages)) {
					  const messageList = document.getElementById('chat-text');
					  messageList.innerHTML = ''; // Clear the list
					  data.messages.forEach(message => {
						  document.querySelector('#chat-text').value += (message.sender + ': ' + message.content + '\n');
					  });
				  } else {
					  console.error('Unexpected response format:', data);
				  }
			  })
			  .catch(error => console.error('Error loading messages:', error));
		  }
	
		function initializeWebSocket(friendId) {
		  if (chatSocket) {
			chatSocket.close();
		  }
	
		  const userId = {{ request.user.id }};
		  chatSocket = new WebSocket(`ws://${window.location.host}/ws/chat/${userId}/${friendId}/`);
	
		  chatSocket.onmessage = function(e) {
			const data = JSON.parse(e.data);
			const chatText = document.getElementById('chat-text');
			chatText.value += `${data.sender}: ${data.message}\n`;
		  };
	
		  chatSocket.onclose = function(e) {
			console.error('Chat socket closed');
		  };
		}
	
		document.getElementById('send').onclick = sendMessage;
		document.getElementById('message').addEventListener('keypress', function(e) {
		  if (e.key === 'Enter') {
			sendMessage();
		  }
		});
	
		function sendMessage() {
		  const messageInput = document.getElementById('message');
		  const message = messageInput.value.trim();
		  if (message && chatSocket.readyState === WebSocket.OPEN) {
			chatSocket.send(JSON.stringify({
			  'message': message,
			  'friend_id': selectedFriendId
			}));
			messageInput.value = '';
		  }
		}
	
		document.getElementById('leave').onclick = function() {
		  if (chatSocket) {
			chatSocket.close();
		  }
		  document.getElementById('chatRoom').style.display = 'none';
		  document.getElementById('friendsList').style.display = 'block';
		  document.getElementById('message').disabled = true;
		  document.getElementById('send').disabled = true;
		  document.getElementById('chat-text').value = '';
		  document.getElementById('message').value = '';
		};
	
		function blockUser(userId) {
		  fetch(`/api/block/${userId}/`, {
			method: 'POST',
			headers: {
			  'Content-Type': 'application/json',
			  'X-CSRFToken': '{{ csrf_token }}'
			},
			body: JSON.stringify({})
		  })
			.then(response => response.json())
			.then(data => {
			  updateFriendDropdown();
			  loadFriends(); // Reload the friend list to update the button states
			});
		}
	
		function unblockUser(userId) {
		  fetch(`/api/unblock/${userId}/`, {
			method: 'POST',
			headers: {
			  'Content-Type': 'application/json',
			  'X-CSRFToken': '{{ csrf_token }}'
			},
			body: JSON.stringify({})
		  })
			.then(response => response.json())
			.then(data => {
			  updateFriendDropdown();
			  loadFriends(); // Reload the friend list to update the button states
			});
		}
	
		loadFriends();
	  });


	</script>
	</body>
	</html>
	
	
